**题目描述**

Given two words (*beginWord* and *endWord*), and a dictionary's word list, find all shortest transformation sequence(s) from *beginWord* to *endWord*, such that:

1. Only one letter can be changed at a time
2. Each transformed word must exist in the word list. Note that *beginWord* is *not* a transformed word.

**Note:**

- Return an empty list if there is no such transformation sequence.
- All words have the same length.
- All words contain only lowercase alphabetic characters.
- You may assume no duplicates in the word list.
- You may assume *beginWord* and *endWord* are non-empty and are not the same.

**Example 1:**

```
Input:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

Output:
[
  ["hit","hot","dot","dog","cog"],
  ["hit","hot","lot","log","cog"]
]
```

**Example 2:**

```
Input:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

Output: []

Explanation: The endWord "cog" is not in wordList, therefore no possible transformation.
```

**难度系数**  

Hard

参考：https://leetcode-cn.com/problems/word-ladder-ii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-3-3/

解法一：DFS解决，主要通过剪枝来缩短运算时间

```c++
class Solution {
  public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
    List<List<String>> ans = new ArrayList<>();
    // 如果不含有结束单词，直接结束，不然后边会造成死循环
    if (!wordList.contains(endWord)) {
      return ans;
    }
    // 利用 BFS 得到所有的邻居节点,以及每个节点的所在层数
    HashMap<String, Integer> distance = new HashMap<>();
    HashMap<String, ArrayList<String>> map = new HashMap<>();
    bfs(beginWord, endWord, wordList, map, distance);
    ArrayList<String> temp = new ArrayList<String>();
    // temp 用来保存当前的路径
    temp.add(beginWord);
    findLaddersHelper(beginWord, endWord, map, distance, temp, ans);
    return ans;
  }

  private void findLaddersHelper(String beginWord, String endWord, HashMap<String, ArrayList<String>> map,
                                 HashMap<String, Integer> distance, ArrayList<String> temp, List<List<String>> ans) {
    if (beginWord.equals(endWord)) {
      ans.add(new ArrayList<String>(temp));
      return;
    }
    // 得到所有的下一个的节点
    /*
      "a"
      "c"
      ["a","b","c"]*/
    //之所以是 map.getOrDefault 而不是 get，就是上边的情况 get 会出错
    ArrayList<String> neighbors = map.getOrDefault(beginWord, new ArrayList<String>());
    for (String neighbor : neighbors) {
      //判断层数是否符合
      if (distance.get(beginWord) + 1 == distance.get(neighbor)) {
        temp.add(neighbor);
        findLaddersHelper(neighbor, endWord, map, distance, temp, ans);
        temp.remove(temp.size() - 1);
      }
    }
  }

  public void bfs(String beginWord, String endWord, List<String> wordList, HashMap<String, ArrayList<String>> map,
                  HashMap<String, Integer> distance) {
    Queue<String> queue = new LinkedList<>();
    queue.offer(beginWord);
    distance.put(beginWord, 0);
    boolean isFound = false;
    int depth = 0;
    Set<String> dict = new HashSet<>(wordList);
    while (!queue.isEmpty()) {
      int size = queue.size();
      depth++;
      for (int j = 0; j < size; j++) {
        String temp = queue.poll();
        // 一次性得到所有的下一个的节点
        ArrayList<String> neighbors = getNeighbors(temp, dict);
        map.put(temp, neighbors);
        for (String neighbor : neighbors) {
          if (!distance.containsKey(neighbor)) {
            distance.put(neighbor, depth);
            if (neighbor.equals(endWord)) isFound = true;
            queue.offer(neighbor);
          }

        }
      }
      if (isFound)  break;//后续的不需要再计算了，因为后面的深度可定大于当前，当然没有这句，也可以AC，只不过会慢一些
    }
  }

  private ArrayList<String> getNeighbors(String node, Set<String> dict) {
    ArrayList<String> res = new ArrayList<String>();
    char chs[] = node.toCharArray();
	
    //考虑单词中每个字符的26种变化情况
    for (char ch = 'a'; ch <= 'z'; ch++) {
      for (int i = 0; i < chs.length; i++) {
        if (chs[i] == ch)
          continue;
        char old_ch = chs[i];
        chs[i] = ch;
        if (dict.contains(String.valueOf(chs))) {
          res.add(String.valueOf(chs));
        }
        chs[i] = old_ch;
      }

    }
    return res;
  }
}
```

解法二：BFS解决，按照层次遍历的方法，一直向下走

```java
public class Solution {
  public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {
    List<List<String>> ans = new ArrayList<>();
    bfs(beginWord, endWord, wordList, ans);
    return ans;
  }

  public void bfs(String beginWord, String endWord, List<String> wordList, List<List<String>> ans) {
    Queue<List<String>> queue = new LinkedList<>();
    List<String> path = new ArrayList<>();
    path.add(beginWord);
    queue.offer(path);
    boolean isFound = false;
    Set<String> dict = new HashSet<>(wordList);
    Set<String> visited = new HashSet<>();
    visited.add(beginWord);
    while (!queue.isEmpty()) {
      int size = queue.size();
      //这里之所以需要如下set，是考虑这种情况，1.hot->tot->bot,2.hot->bot,如果没有subVisited，就不会考虑第二种情况
      Set<String> subVisited = new HashSet<>();
      for (int j = 0; j < size; j++) {
        List<String> p = queue.poll();
        //得到当前路径的末尾单词
        String temp = p.get(p.size() - 1);
        // 一次性得到所有的下一个节点
        ArrayList<String> neighbors = getNeighbors(temp, dict);
        for (String neighbor : neighbors) {
          //只考虑之前没有出现过的单词
          if (!visited.contains(neighbor)) {
            //到达结束单词
            if (neighbor.equals(endWord)) {
              isFound = true;
              p.add(neighbor);
              ans.add(new ArrayList<String>(p));
              p.remove(p.size() - 1);
            }
            //加入当前单词
            p.add(neighbor);
            queue.offer(new ArrayList<String>(p));
            p.remove(p.size() - 1);
            subVisited.add(neighbor);
          }
        }

      }
      visited.addAll(subVisited);
      if (isFound) {
        break;
      }
    }
  }

  private ArrayList<String> getNeighbors(String node, Set<String> dict) {
    ArrayList<String> res = new ArrayList<String>();
    char[] chs = node.toCharArray();
    for (char ch = 'a'; ch <= 'z'; ch++) {
      for (int i = 0; i < chs.length; i++) {
        if (chs[i] == ch)
          continue;
        char old_ch = chs[i];
        chs[i] = ch;
        if (dict.contains(String.valueOf(chs))) {
          res.add(String.valueOf(chs));
        }
        chs[i] = old_ch;
      }
    }
    return res;
  }
}

```



