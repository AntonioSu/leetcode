#### **题目描述**
Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.

Note:  
&emsp; 1.Each of the array element will not exceed 100.  
&emsp; 2.The array size will not exceed 200.
#### **Example1**
```
Input: [1, 5, 11, 5]

Output: true

Explanation: The array can be partitioned as [1, 5, 5] and [11].
```
#### **Example2**
```
Input: [1, 2, 3, 5]

Output: false

Explanation: The array cannot be partitioned into equal sum subsets.
```

思路：只要数组中的数字满足和的一半，就可以，如下算法是针对测试用例而编写  
有一个测试用例：[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,100]

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        if(nums.empty())
            return false;
        int n=nums.size();
        int sum=0;
        for(auto item:nums){
            sum+=item;
        }
        if((sum&1)==1||n==1)
            return false;
        sum=sum>>1;
        sort(nums.begin(),nums.end());
        //第一个不用递归，
        sum=sum-nums[n-1];
        //尽量保证少递归
        return ( dfs(nums,sum,n-2)||dfs(nums,sum-nums[n-2],n-2) );
    }

    bool  dfs(vector<int>& nums,int half_sum,int index){
        if(half_sum==0){
            return true;
        }
        if(index==0||(half_sum<0))
            return false;
        return dfs(nums,half_sum-nums[index-1],index-1)||dfs(nums,half_sum,index-1);
    }
};
```